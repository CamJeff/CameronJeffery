<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>COMP 551 — Applied Machine Learning (Lecture 2)</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <link rel="icon" type="image/png" href="../assets/icon.png">

  <!-- Shared styles -->
  <link rel="stylesheet" href="../COMP_551_Notes/css/style.css">

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        tags: 'ams'
      },
      options: { renderActions: { addMenu: [] } }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <div class="header-inner">
        <div class="brand"><a href="../puzzles/index.html"><strong>Puzzles</strong></a></div>
        <div class="course-title">Fiddler on the Proof Problems</div>
        <div style="text-align:right">
          <button class="sidebar-toggle" aria-expanded="false" aria-controls="sidebar">Lectures</button>
        </div>
      </div>
    </header>

    <nav id="sidebar" class="sidebar" aria-label="Course navigation">
      <h2>Problems</h2>
      <ul class="nav-list">
        <li class="nav-item"><a href="index.html">Homepage</a></li>
        <li class="nav-item"><a href="Oct10.html"><b>October 10:</b> Let’s Make a Tic-Tac-Deal!</a></li>
        <li class="nav-item"><a href="Sept19.html"><b>September 19:</b> Can Your Team Self-Organize?</a></li>
        <li class="nav-item"><a href="Sept5.html"><b>September 5 :</b> How Low (or High) Can You Go?</a></li>
        <li class="nav-item"><a href="Aug22.html"><b>August 22:</b> How Far Can You Run Before Sundown?</a></li>
        <li class="nav-item"><a href="Aug15.html"><b>August 15:</b> How Much Free Money Can You Win?</a></li>
        <li class="nav-item"><a href="July25.html"><b>July 25:</b> Can You Sprint to the Finish?</a></li>
      </ul>
    </nav>
    
    <main>
      <!-- Minimal skeleton for Lecture 2 content; ready to fill later -->
      <section id="lecture-2" class="section">
        <h1><a href="https://thefiddler.substack.com/p/how-far-can-you-run-before-sundown" target="_blank" rel="noopener">August 22: How Far Can You Run Before Sundown?</a></h1>
        <div class="spacer"></div>
        <div class="card">
         <h2>Puzzle</h2>

            <p>You’re participating in a trail run that ends at sundown at $7$ p.m. There are four loops: $1$ mile, $3$ miles, $3.5$ miles, and $4.5$ miles. After completing any given loop, you are randomly assigned another loop to run—this next loop could be the same as the previous one you just ran, or it could be one of the other three. Being assigned your next loop doesn’t take a meaningful amount of time; assume all your time is spent running.</p>


            <p>Your "score" in the race is the total distance you run among all completed loops you are assigned. If you’re still out on a loop at $7$ p.m., any completed distance on that loop does not count toward your score!</p>

            <p>It is now $5:55$ p.m. and you have just completed a loop. So far, you’ve been running $10$-minute miles the whole way. You’ll maintain that pace until $7$ p.m.</p>

            <p>On average, what score can you expect to earn between $5:55$ p.m. and $7$ p.m.?</p>

          <hr class="card-divider">

            <h2>Solution</h2>

            <p>Let $\mathscr{T}(t)$ be the expected completed running time you obtain when starting a loop with $t$ minutes left. From $5:55-7:00$, there are $65$ minutes left. Since we take $10$ minutes for every mile, the expected number of miles we run in this time is:</p>

            $$\mathbb{E}[\text{Miles}]=\frac{\mathscr{T}(t)}{10}$$

            <p>Each loop will take times: $\mathscr{L}\in \{10,30,35,45\}$, and they are chosen uniformly at random. For $t$ minutes on the clock, we say that if $\mathscr{L}\leq t$, we collect $\mathscr{L}$ minutes, and continue racing for $t-\mathscr{L}$ minutes. If $\mathscr{L}>t$, then we will not complete the loop, and we will score $0$ for this. Thus, using the law of total expectation, we can express $\mathscr{T}(t)$ recursively as:</p>

            \begin{align*}
    \mathscr{T}(t) & = \mathbb{E}\left[\mathbb{I}_{\{\mathscr{L}\leq t\}}\left(\mathscr{L}+\mathscr{T}(t-\mathscr{L})\right)\right]= \sum_{\mathscr{L}\in \{10,30,35,45\}}\mathbb{P}(\mathscr{L})\mathbb{I}_{\mathscr{L}\leq t}\left(\mathscr{L}+\mathscr{T}(t-\mathscr{L})\right)
\end{align*}

                <p>And since the times from $\mathscr{L}$ are chosen uniformly at random, we have:</p>

                $$\mathscr{T}(t)=\frac 14\sum_{\mathscr{L}\in \{10,30,35,45\}} \mathbb{I}_{\mathscr{L}\leq t}\left(\mathscr{L}+\mathscr{T}(t-\mathscr{L})\right)$$

                <p>We will always complete loops at times that are multiples of $5$, so we only need to check for times $t=0,5,10,\dots$ and so on. Some useful base cases: $\mathscr{T}(0)=\mathscr{T}(5)=0$. As an example, if there was less than 30 minutes remaining, only $\mathscr{L}=10$ minute loops count, and so we compute
</p>

                \begin{align*}
    \mathscr{T}(10) & = \frac 14 \left(10+\mathscr{T}(0)\right)=2.5
    \\ \mathscr{T}(15) & = \frac 14\left(10+\mathscr{T}(5)\right)=2.5
    \\ \mathscr{T}(20) & = \frac 14 \left(10+\mathscr{T}(10)\right)=3.125
    \\ & \vdots
\end{align*}

            <p>And I'm already bored. We would continue by adding subsequent terms in our summation for different $\mathscr{L}$ value times allowed, but this is a long process to do by hand. Below is small python program that will use this recursive formula to find the desired output $\mathscr{T}(65)$, and then also print the expected miles we run (by dividing $\mathscr{T}(65)$ by $10$).</p>


                                                <div class="code-cell">
  <pre><code class="language-python">
from functools import lru_cache

LOOP_TIMES = (10, 30, 35, 45)
P = 1.0 / 4.0  # Probability a given loop is selected

@lru_cache(None)
def expected_completion_times(t: int) -> float:
    if t < min(LOOP_TIMES):
        return 0.0
    return P * sum((L + expected_completion_times(t - L)) if L <= t else 0.0 for L in LOOP_TIMES)

val_minutes = expected_completion_times(65)
val_miles = val_minutes / 10.0

print(f"T(65) = {val_minutes:.10f}")
print(f"Expected score = {val_miles:.10f} miles.")
  </code></pre>
</div>

<p>And we get $\mathscr{T}(65)=48.6645...$, and therefore our expected score is $4.866..$, or rounded as $\boxed{4.87}$.</p>
            


        </div>
      </section>
    </main>
  </div>

  <script>
    // Sidebar mobile toggle
    const sidebar = document.getElementById('sidebar');
    const toggleBtn = document.querySelector('.sidebar-toggle');
    function toggleSidebar() {
      const isOpen = sidebar.style.display === 'block';
      sidebar.style.display = isOpen ? 'none' : 'block';
      toggleBtn.setAttribute('aria-expanded', String(!isOpen));
    }
    if (toggleBtn) toggleBtn.addEventListener('click', toggleSidebar);

    // Active link handling:
    // 1) Highlight the link that points to the current page (by pathname)
    // 2) When scrolling within this page, update the active link to the visible section
    const links = Array.from(document.querySelectorAll('.nav-item a'));

    // Highlight by current page
    links.forEach(a => {
      const url = new URL(a.getAttribute('href'), location.href);
      if (url.pathname === location.pathname) a.classList.add('active');
    });

    // If there are in-page sections, also track by intersection
    const sectionAnchors = links
      .map(a => {
        const url = new URL(a.getAttribute('href'), location.href);
        return url.pathname === location.pathname && url.hash
          ? document.querySelector(url.hash)
          : null;
      })
      .filter(Boolean);

    if (sectionAnchors.length) {
      const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          const id = '#' + entry.target.id;
          links.forEach(l => {
            const url = new URL(l.getAttribute('href'), location.href);
            if (url.pathname === location.pathname && url.hash === id) {
              l.classList.toggle('active', entry.isIntersecting);
            }
          });
        });
      }, { rootMargin: '-40% 0px -45% 0px', threshold: [0, 1] });

      sectionAnchors.forEach(sec => observer.observe(sec));
    }
  </script>
</body>
</html>