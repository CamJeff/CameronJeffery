<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>COMP 551 — Applied Machine Learning (Lecture 2)</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <link rel="icon" type="image/png" href="../assets/icon.png">

  <!-- Shared styles -->
  <link rel="stylesheet" href="../COMP_551_Notes/css/style.css">

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        tags: 'ams'
      },
      options: { renderActions: { addMenu: [] } }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <div class="header-inner">
        <div class="brand"><a href="../puzzles/index.html"><strong>Puzzles</strong></a></div>
        <div class="course-title">Jane Street Puzzles</div>
        <div style="text-align:right">
          <button class="sidebar-toggle" aria-expanded="false" aria-controls="sidebar">Lectures</button>
        </div>
      </div>
    </header>

    <nav id="sidebar" class="sidebar" aria-label="Course navigation">
      <h2>Puzzles</h2>
      <ul class="nav-list">
        <li class="nav-item"><a href="index.html">Homepage</a></li>
        <li class="nav-item"><a href="Oct2025.html"><b>October 2025:</b> Robot Baseball</a></li>
        <li class="nav-item"><a href="Sept2025.html"><b>September 2025:</b> Hooks 11</a></li>
        <li class="nav-item"><a href="July2025.html"><b>July 2025:</b> Robot Road Trip</a></li>
        <li class="nav-item"><a href="April2025.html"><b>April 2025:</b> Sum One, Somewhere</a></li>
        <li class="nav-item"><a href="Nov2024.html"><b>November 2024:</b> Beside the Point</a></li>
        <li class="nav-item"><a href="Oct2024.html"><b>October 2024:</b> Knight Moves 6</a></li>
      </ul>
    </nav>

    <main>
      <!-- Minimal skeleton for Lecture 2 content; ready to fill later -->
      <section id="lecture-2" class="section">
        <h1><a href="https://www.janestreet.com/puzzles/sum-one-somewhere-index/" target="_blank" rel="noopener">April 2025: Sum One, Somewhere</a></h1>
        <div class="spacer"></div>
        <div class="card">
            <h2>Puzzle</h2>

            <p>For a fixed $p$, independently label the nodes of an infinite complete binary tree $0$ with probability $p$, and $1$ otherwise. For what $p$ is there exactly a $1/2$ probability that there exists an infinite path down the tree that sums to at most $1$ (that is, all nodes visited, with the possible exception of one, will be labeled $0$). Find this value of $p$ accurate to $10$ decimal places.</p>

            <img src="Pics/sum-one-somewhere.png" alt="NLL" class="centered-image">

            <hr class="card-divider">

            <h2>Solution</h2>

            <p>The intuition behind my approach was to use the symmetry of an infinite binary tree. Once you move along an edge to a given node, you are once again faced with an infinite binary tree and it’s like you started from the beginning again. By that logic, it is sufficient to analyze the probability for the first two levels and we can let recursion handle the rest.</p>

            <p>Let:</p>

            $$\beta=\text{probability from the root, there is at least one}$$
$$\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{infinite path with sum }\leq1\;\text{(call it a "good" path)}$$

            <p>Then the total probability is given by:</p>

            $$\beta=\underbrace{p}_{\substack{\text{probability} \\\text{root is 0}}}\underbrace{\left[1-(1-\beta)^2\right]}_{\substack{\text{probability} \\ \text{that at least} \\ \text{one child is root} \\ \text{of subtree with} \\ \text{"good" path}}}+\underbrace{(1-p)}_{\substack{\text{probability}\\\text{root is 1}}}\underbrace{\left[1-(1-q)^2\right]}_{\substack{\text{probability} \\ \text{that at least} \\ \text{one child is root} \\ \text{of subtree whose} \\ \text{nodes are all 0}}}$$

            <p>Where:</p>

            $$q=\text{probability a node is the root of}$$
$$\;\;\;\text{infinite subtree of all 0 nodes}$$

            <p>And can be expressed as:</p>

            \begin{align*}
q & =\mathbb{P}(\text{root is 0})\mathbb{P}(\text{root has at least one 0 child})    
\\ & = p\left[1-(1-q)^2\right]
\end{align*}

            <p>Solving gives:</p>

            $$q(pq-2p+1)=0\implies \begin{cases}
    q=0 \\ q=\frac{2p-1}{p}=2-\frac 1p
\end{cases}$$

            <p>And notice that:</p>

            $$q\geq 0\implies 2-\frac 1p \geq 0\implies 2\geq \frac 1p \implies p\geq \frac 12$$

            <p>So:</p>

            $$\frac 12 \leq p\leq 1$$

            <p>So now, back to our expression for $\beta$, we substitute in $q=\left(2-\frac 1p\right)$, and we solve for $p$ when we let $\beta=\frac 12$:</p>

            $$\frac 12 =p\left[1-\left(1-\frac 12\right)^2\right]+(1-p)\left[1-\left(1-2+\frac 1p\right)^2\right]$$

            <p>Which arrives at the cubic polynomial:</p>

            $$\boxed{3p^3-10p^2+12p-4=0}$$

            <p>Since the solution calls for a value of $p$ to 10 decimal places, I'm assuming there is no exact solution for $p$ in the above cubic (but it's not like I tried that hard to find one either lol). </p>

            <p>Instead, I opted for a Newton-Raphson method to numerically find the root the cubic. The following page shows the implementation.</p>

                                    <div class="code-cell">
  <pre><code class="language-python">
from decimal import Decimal, getcontext

# Set precision high 
getcontext().prec = 50

def f(x):
    return 3 * x**3 - 10 * x**2 + 12 * x - 4

def f_prime(x):
    return 9 * x**2 - 20 * x + 12

def newton_raphson(x0, tol=Decimal('1e-30'), max_iter=100):
    x = x0
    for _ in range(max_iter):
        fx = f(x)
        fpx = f_prime(x)
        if fpx == 0:
            raise ZeroDivisionError("Derivative is zero.")
        x_new = x - fx / fpx
        if abs(x_new - x) < tol:
            return x_new
        x = x_new
    raise RuntimeError("Newton-Raphson did not converge.")

# Initial guess near the first root
initial_guess = Decimal('0.5')
root = newton_raphson(initial_guess)

# Compute absolute error
error = abs(f(root))

print("Root:", format(root, '.20f'))
print("Error:", format(error, '.3e'))
  </code></pre>
</div>

      <p>Which gives a root of:</p>

      $$\boxed{p=\texttt{0.53060357543000532080}}$$
        </div>
      </section>
    </main>
  </div>

  <script>
    // Sidebar mobile toggle
    const sidebar = document.getElementById('sidebar');
    const toggleBtn = document.querySelector('.sidebar-toggle');
    function toggleSidebar() {
      const isOpen = sidebar.style.display === 'block';
      sidebar.style.display = isOpen ? 'none' : 'block';
      toggleBtn.setAttribute('aria-expanded', String(!isOpen));
    }
    if (toggleBtn) toggleBtn.addEventListener('click', toggleSidebar);

    // Active link handling:
    // 1) Highlight the link that points to the current page (by pathname)
    // 2) When scrolling within this page, update the active link to the visible section
    const links = Array.from(document.querySelectorAll('.nav-item a'));

    // Highlight by current page
    links.forEach(a => {
      const url = new URL(a.getAttribute('href'), location.href);
      if (url.pathname === location.pathname) a.classList.add('active');
    });

    // If there are in-page sections, also track by intersection
    const sectionAnchors = links
      .map(a => {
        const url = new URL(a.getAttribute('href'), location.href);
        return url.pathname === location.pathname && url.hash
          ? document.querySelector(url.hash)
          : null;
      })
      .filter(Boolean);

    if (sectionAnchors.length) {
      const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          const id = '#' + entry.target.id;
          links.forEach(l => {
            const url = new URL(l.getAttribute('href'), location.href);
            if (url.pathname === location.pathname && url.hash === id) {
              l.classList.toggle('active', entry.isIntersecting);
            }
          });
        });
      }, { rootMargin: '-40% 0px -45% 0px', threshold: [0, 1] });

      sectionAnchors.forEach(sec => observer.observe(sec));
    }
  </script>
</body>
</html>